
import { connectMySQL } from "../config/sqlconfig.js";
const connection = await connectMySQL();

// STORING 
export const OrgDataStorage = async (clientname, orgname, orgcode, address, country, state, city, postalCode, phoneNumber, emailAddress, PAN, GST, IEC, creditdays, branchName, username, createdon) => {
    try {

        // Check if data exists in the users table for the provided orgname and orgcode
        const [row] = await connection.execute(`
            SELECT * FROM users WHERE orgname = ? AND orgcode = ?
        `, [orgname, orgcode]);

        // Extract alias from orgname
        const firstEmptyIndex = clientname.indexOf(' ');
        const aliasisthis = clientname.slice(0, firstEmptyIndex !== -1 ? firstEmptyIndex : orgname.length).toLowerCase();

        // Insert data into the organizations table
        const [rows] = await connection.execute(`
            INSERT INTO crm_db.approvalorg (clientname, alias, address, country, state, city, postalcode, phone, email, PAN, GST, IEC, creditdays, orgname, orgcode, branchname, username, uniquevalue, createdon)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [clientname, aliasisthis, address, country, state, city, postalCode, phoneNumber, emailAddress, PAN, GST, IEC, creditdays, orgname, orgcode, branchName, username, "OrgButton", createdon]);
        const insertedId = rows.insertId;

        const [approverrows] = await connection.execute(`SELECT * FROM approvername WHERE orgname = ? AND orgcode = ?`, [orgname, orgcode])

        const orgrows = approverrows.filter((item) => {
            // Check if uniquevalue is an array and its first element is 'OrgButton'
            return Array.isArray(item.uniquevalue) && item.uniquevalue[0] === 'OrgButton';
        });

        const valuesArray = [];
        const readingarray = [];
        const timeofreading = [];
        // Iterate over each row in orgrows
        orgrows.forEach((item) => {
            // Extract the employeename from the current row
            const employeename = item.employeename;
            valuesArray.push({
                employeename: employeename // Insert employeename into approvername column
            });

            readingarray.push({
                employeename: employeename,
                read: 0,
                approved: 0
            })

            timeofreading.push({
                employeename: employeename,
                time: null
            })

        });


        const [rowsnotifications] = await connection.execute(`
            INSERT INTO crm_db.notifications (clientname, alias, address, country, state, city, postalcode, phone, email, PAN, GST, IEC, creditdays, orgname, orgcode, branchname, username, uniquevalue, approvername, reading, timeofreading, approvalid, createdat)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [clientname, aliasisthis, address, country, state, city, postalCode, phoneNumber, emailAddress, PAN, GST, IEC, creditdays, orgname, orgcode, branchName, username, "OrgButton", valuesArray, readingarray, timeofreading, insertedId, createdon]);

        // Get the auto-generated ID of the inserted row
        const [rowWithAutoGeneratedId] = await connection.execute('SELECT LAST_INSERT_ID() as id');

        // Extract the auto-generated ID from the row
        const autoGeneratedId = rowWithAutoGeneratedId[0].id;

        return autoGeneratedId;
    } catch (error) {
        console.error('Error inserting organization data:', error.message);
        throw error;
    }
}


// RENDER ON ORGANIZATION PAGE
// export const OrgRender = async (orgname, orgcode) => {
//     try {
//         const connection = await connectMySQL();

//         const [row] = await connection.execute(`
//             SELECT clientname, alias, branchname FROM organizations WHERE orgname = ? AND orgcode = ?
//         `, [orgname, orgcode]);

//         return row;
//     } catch (error) {
//         console.error('Error fetching organization data:', error.message);
//         throw error;
//     }
// }






// export const OrgRender = async (orgname, orgcode) => {
//     try {
//         const connection = await connectMySQL();

//         const [rows] = await connection.execute(`
//             SELECT clientname, alias, branchname
//             FROM organizations
//             WHERE orgname = ? AND orgcode = ?
//         `, [orgname, orgcode]);
//         console.log(rows);
//         if (rows.length > 0) {
//             const branchNames = rows.map(row => row.branchname); // Use map instead of forEach
//             const organizationData = {
//                 clientname: rows[0].clientname,
//                 alias: rows[0].alias,
//                 allbranchesofclient: branchNames
//             };

//             return organizationData;
//         } else {
//             return null; // Handle case where organization not found
//         }
//     } catch (error) {
//         console.error('Error fetching organization data:', error.message);
//         throw error;
//     }
// }





export const OrgRender = async (orgname, orgcode) => {
    try {

        const [rows] = await connection.execute(`
            SELECT clientname, alias, branchname, id
            FROM organizations
            WHERE orgname = ? AND orgcode = ?
        `, [orgname, orgcode]);

        if (rows.length > 0) {
            const clientsMap = new Map(); // Map to store clients and their branches
            rows.forEach(row => {
                const { clientname, alias, branchname, id } = row;
                if (clientsMap.has(alias)) {
                    clientsMap.get(alias).branches.push({ branchname, id });
                } else {
                    clientsMap.set(alias, { clientname, alias, branches: [{ branchname, id }] });
                }
            });

            const organizationData = Array.from(clientsMap.values());
            return organizationData.flat(); // Flatten the array
        } else {
            return null; // Handle case where organization not found
        }
    } catch (error) {
        console.error('Error fetching organization data:', error.message);
        throw error;
    }
}



















// ADD USER VIA ADMIN API
export const insertEmployees = async (username, password, orgcode, orgname, fullname, role) => {
    try {

        // Check if the organization exists in the users table
        const [rows] = await connection.execute(`
            SELECT * FROM users WHERE orgcode = ? AND orgname = ?
        `, [orgcode, orgname]);

        // If the organization doesn't exist, throw an error
        if (rows.length === 0) {
            throw new Error('Organization does not exist');
        }

        const usernameofuser = username+'@'+role;
        // Insert employee data into the employees table
        await connection.execute(`
            INSERT INTO employees (username, password, orgcode, orgname, fullname, role) 
            VALUES (?, ?, ?, ?, ?, ?)
        `, [usernameofuser, password, orgcode, orgname, fullname, role]);

        return rows;
    } catch (error) {
        console.error('Error inserting employee data:', error.message);
        throw error;
    }
}



export const fetchBranchData = async (clientname, alias, branchname, id) => {
    try {

        const [row] = await connection.execute(`SELECT * FROM organizations WHERE clientname = ? AND alias = ? AND branchname = ? AND id = ?`, [clientname, alias, branchname, id]);

        return row[0];
    } catch (error) {
        console.error('Error inserting employee data:', error.message);
        throw error;
    }
}






export const updateRow = async (orgcode, orgname, clientname, alias, branchname, id, address, country, state, city, postalcode, phone, email, PAN, GST, IEC, creditdays) => {
    try {

        const [row] = await connection.execute(`
            UPDATE approvalorg
            SET 
                address = ?,
                country = ?,
                state = ?,
                city = ?,
                postalcode = ?,
                phone = ?,
                email = ?,
                PAN = ?,
                GST = ?,
                IEC = ?,
                creditdays = ?
            WHERE 
                orgcode = ? AND
                orgname = ? AND
                branchname = ? AND
                clientname = ? AND
                alias = ? AND
                id = ?
        `, [
            address, country, state, city, postalcode, phone, email, PAN, GST, IEC, creditdays,
            orgcode,
            orgname,
            branchname,
            clientname,
            alias,
            id
        ]);


        return row;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}




// STORE CONTACTS
export const insertContact = async (contactName, designation, department, mobile, email, branchname, orgname, orgcode, id, clientname) => {
    try {
        const row = await connection.execute(`INSERT INTO contacts 
        (contactName, designation, department, mobile, email, branchname, orgname, orgcode, clientname, bid) 
        VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [contactName, designation, department, mobile, email, branchname, orgname, orgcode, clientname, id]);
        return row;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}



export const fetchAllContacts = async (branchname, clientname, id, orgname, orgcode) => {
    try {

        const [rows] = await connection.execute(`SELECT * FROM contacts WHERE branchname = ? AND orgname = ? AND orgcode = ? AND clientname = ? AND bid = ?`, [branchname, orgname, orgcode, clientname, id]);
        return rows;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}

export const fetchAllContactsofNew = async (branchname, clientname, orgname, orgcode) => {
    try {

        const [rows] = await connection.execute(`SELECT * FROM contacts WHERE branchname = ? AND orgname = ? AND orgcode = ? AND clientname = ? AND bid IS NULL`, [branchname, orgname, orgcode, clientname]);
        return rows;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}


export const updateContactduringNew = async (contactName, designation, department, mobile, email, branchname, orgname, orgcode, clientname) => {
    try {

        const row = await connection.execute(`UPDATE contacts SET contactName = ?, designation = ?, department = ?, mobile = ?, email = ? WHERE branchname = ? AND orgname = ? AND orgcode = ? AND clientname = ? AND mobile = ?`,
            [contactName, designation, department, mobile, email, branchname, orgname, orgcode, clientname, mobile]);
        return row;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}



export const deleteContact = async (email, mobile, contactName, designation, department) => {
    try {

        const row = await connection.execute(`DELETE FROM contacts WHERE email = ? AND mobile = ? AND contactName = ? AND designation = ? AND department = ?`, [email, mobile, contactName, designation, department]);
        return row;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}


export const updateContact = async (contactName, designation, department, mobile, email, branchname, clientname, id, orgname, orgcode) => {
    try {

        const row = await connection.execute(
            `UPDATE contacts SET contactName = ?, designation = ?, department = ?, mobile = ?, email = ? WHERE branchname = ? AND orgname = ? AND orgcode = ? AND clientname = ? AND bid = ? AND mobile = ?`,
            [contactName, designation, department, mobile, email, branchname, orgname, orgcode, clientname, id, mobile]
        );
        return row;
    } catch (error) {
        console.error('Error updating row:', error.message);
        throw error;
    }
}




export const saveBranchinTable = async (clientname, orgcode, branchname) => {
    try {

        const [row] = await connection.execute(`INSERT INTO branches (clientname, orgcode, branchname) VALUES (?, ?, ?)`, [clientname, orgcode, branchname]);
        return {
            row,
            branchname
        }
    } catch (error) {
        console.log(error);
    }
}



export const updateBID = async (BID, clientname, orgcode, branchname) => {
    try {

        const [row] = await connection.execute(`
            UPDATE branches 
            SET bid = ? 
            WHERE clientname = ? AND orgcode = ? AND branchname = ? AND bid IS NULL
        `, [BID, clientname, orgcode, branchname]);

        if (row.affectedRows === 0) {
            throw new Error('Branch not found or BID was not updated');
        }

        return { success: true, message: 'BID updated successfully' };
    } catch (error) {
        console.log(error);
        return { success: false, message: 'Error updating BID' };
    }
}


export const updateBIDContact = async (BID, clientname, orgcode, orgname, branchname) => {
    try {

        const [row] = await connection.execute(`
            UPDATE contacts 
            SET bid = ? 
            WHERE clientname = ? AND orgcode = ? AND orgname = ? AND branchname = ? AND bid IS NULL
        `, [BID, clientname, orgcode, orgname, branchname]);
        return row;
    } catch (error) {
        console.log(error);
        return { success: false, message: 'Error updating BID' };
    }
}





export const deleteBranch = async (id, branchname, orgcode, orgname, clientname) => {
    try {

        // Delete branch from organizations table
        const [orgRow] = await connection.execute(`
            DELETE FROM approvalorg 
            WHERE id = ? AND branchname = ? AND orgcode = ? AND orgname = ? AND clientname = ?
        `, [id, branchname, orgcode, orgname, clientname]);

        // Delete branch from branches table
        const [branchRow] = await connection.execute(`
            DELETE FROM branches 
            WHERE bid = ? AND orgcode = ? AND clientname = ? AND branchname = ?
        `, [id, orgcode, clientname, branchname]);

        // Delete contacts from contacts table
        const [deletedContacts] = await connection.execute(`DELETE FROM contacts 
            WHERE branchname = ? AND bid = ? AND orgcode = ? AND orgname = ? AND clientname = ?
        `, [branchname, id, orgcode, orgname, clientname]);

        return { branchRow, orgRow, deletedContacts };

    } catch (error) {
        console.log(error);
    }
}




export const getOrgsforfiltering = async (orgname, orgcode) => {
    try {
        const [rows] = await connection.execute(`SELECT clientname FROM organizations WHERE orgname = ? AND orgcode = ?`, [orgname, orgcode]);
        return rows;
    } catch (error) {
        console.log(error);
    }
}